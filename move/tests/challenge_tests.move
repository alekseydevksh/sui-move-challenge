#[test_only]
module challenge::arena_tests;

// ========================== DO NOT EDIT THIS FILE ==========================

use challenge::arena::{Self, Arena, ArenaCreated, ArenaCompleted};
use challenge::hero::{Self, Hero, HeroMetadata};
use challenge::marketplace::{Self, ListHero, AdminCap, EInvalidPayment, HeroListed, HeroBought};
use std::string::{Self as string};
use sui::coin;
use sui::sui::SUI;
use sui::test_scenario::{Self as ts, next_tx};
use sui::test_utils::destroy;

// Error codes for assertions
const EHeroNameMismatch: u64 = 1;
const EHeroImageUrlMismatch: u64 = 2;
const EHeroPowerMismatch: u64 = 3;
const EHeroPriceMismatch: u64 = 4;
const EHeroNotCreated: u64 = 5;
const EHeroNotTransferred: u64 = 6;
const EListHeroNotShared: u64 = 7;
const EArenaNotShared: u64 = 8;
const EHeroAmountMismatch: u64 = 9;
const EDidNotEmitEvent: u64 = 10;

const SENDER: address = @0x1;
const RECIPIENT: address = @0x2;
const PRICE: u64 = 1_000_000_000; // 1 SUI in MIST

#[test]
fun test_create_hero() {
    let mut scenario = ts::begin(SENDER);

    // Create a hero
    {
        hero::create_hero(
            b"Ali".to_string(),
            b"https://example.com/ali.png".to_string(),
            9000,
            scenario.ctx(),
        );
    };

    // Move to next transaction to access the created hero
    next_tx(&mut scenario, SENDER);

    // Verify hero was created and test getter functions
    assert!(ts::has_most_recent_for_sender<Hero>(&scenario), EHeroNotCreated);

    // Will revert if taking object which is not shared
    let metadata = scenario.take_immutable<HeroMetadata>();

    {
        let hero = ts::take_from_sender<Hero>(&scenario);
        // Test getter functions
        assert!(hero::hero_name(&hero) == b"Ali".to_string(), EHeroNameMismatch);
        assert!(
            hero::hero_image_url(&hero) == b"https://example.com/ali.png".to_string(),
            EHeroImageUrlMismatch,
        );
        assert!(hero::hero_power(&hero) == 9000, EHeroPowerMismatch);
        ts::return_to_sender(&scenario, hero);
    };

    destroy(metadata);
    ts::end(scenario);
}

#[test]
fun test_transfer_hero() {
    let mut scenario = ts::begin(SENDER);

    // Create a hero first
    {
        hero::create_hero(
            b"Serkan".to_string(),
            b"https://example.com/serkan.png".to_string(),
            8500,
            scenario.ctx(),
        );
    };

    next_tx(&mut scenario, SENDER);

    // Transfer the hero to recipient
    {
        let hero = ts::take_from_sender<Hero>(&scenario);
        transfer::public_transfer(hero, RECIPIENT)
    };

    // Move to next transaction as recipient
    next_tx(&mut scenario, RECIPIENT);

    // Verify hero is now owned by recipient
    assert!(ts::has_most_recent_for_address<Hero>(RECIPIENT), EHeroNotTransferred);

    ts::end(scenario);
}

#[test]
fun test_list_hero() {
    let mut scenario = ts::begin(SENDER);

    // Create a hero first
    {
        hero::create_hero(
            b"Mantas".to_string(),
            b"https://example.com/mantas.png".to_string(),
            7500,
            scenario.ctx(),
        );
    };

    next_tx(&mut scenario, SENDER);

    // List the hero for sale
    {
        let hero = ts::take_from_sender<Hero>(&scenario);

        marketplace::list_hero(hero, PRICE, scenario.ctx());
        assert!(sui::event::events_by_type<HeroListed>().length() == 1, EDidNotEmitEvent);
    };

    next_tx(&mut scenario, SENDER);

    // Verify ListHero object was created and shared
    assert!(ts::has_most_recent_shared<ListHero>(), EListHeroNotShared);

    ts::end(scenario);
}

#[test]
fun test_buy_hero() {
    let mut scenario = ts::begin(SENDER);

    // Create and list a hero
    {
        hero::create_hero(
            b"Teo".to_string(),
            b"https://example.com/teo.png".to_string(),
            6000,
            scenario.ctx(),
        );
    };

    next_tx(&mut scenario, SENDER);

    {
        let hero = ts::take_from_sender<Hero>(&scenario);

        marketplace::list_hero(hero, PRICE, scenario.ctx());
    };

    next_tx(&mut scenario, RECIPIENT);

    // Buy the hero
    {
        let coin = coin::mint_for_testing<SUI>(PRICE, scenario.ctx());
        let list_hero = ts::take_shared<ListHero>(&scenario);

        marketplace::buy_hero(list_hero, coin, scenario.ctx());
        assert!(sui::event::events_by_type<HeroBought>().length() == 1, EDidNotEmitEvent);
    };

    next_tx(&mut scenario, RECIPIENT);

    // Verify buyer received the hero
    assert!(ts::has_most_recent_for_address<Hero>(RECIPIENT), EHeroNotTransferred);

    {
        let hero = ts::take_from_address<Hero>(&scenario, RECIPIENT);
        assert!(hero::hero_name(&hero) == b"Teo".to_string(), EHeroNameMismatch);
        assert!(hero::hero_power(&hero) == 6000, EHeroPowerMismatch);
        ts::return_to_address(RECIPIENT, hero);
    };

    ts::end(scenario);
}

#[test]
#[expected_failure(abort_code = EInvalidPayment)]
fun test_buy_hero_payment_too_low() {
    let mut scenario = ts::begin(SENDER);

    // Create and list a hero
    {
        hero::create_hero(
            b"Teo".to_string(),
            b"https://example.com/teo.png".to_string(),
            6000,
            scenario.ctx(),
        );
    };

    next_tx(&mut scenario, SENDER);

    {
        let hero = ts::take_from_sender<Hero>(&scenario);

        marketplace::list_hero(hero, PRICE, scenario.ctx());
    };

    next_tx(&mut scenario, RECIPIENT);

    // Buy the hero
    {
        let too_low_payment = coin::mint_for_testing<SUI>(PRICE / 2, scenario.ctx());
        let list_hero = ts::take_shared<ListHero>(&scenario);

        marketplace::buy_hero(list_hero, too_low_payment, scenario.ctx());
    };

    next_tx(&mut scenario, RECIPIENT);

    scenario.end();
}

#[test]
#[expected_failure(abort_code = EInvalidPayment)]
fun test_buy_hero_payment_too_high() {
    let mut scenario = ts::begin(SENDER);

    // Create and list a hero
    {
        hero::create_hero(
            b"Teo".to_string(),
            b"https://example.com/teo.png".to_string(),
            6000,
            scenario.ctx(),
        );
    };

    next_tx(&mut scenario, SENDER);

    {
        let hero = ts::take_from_sender<Hero>(&scenario);

        marketplace::list_hero(hero, PRICE, scenario.ctx());
    };

    next_tx(&mut scenario, RECIPIENT);

    // Buy the hero
    {
        let too_low_payment = coin::mint_for_testing<SUI>(PRICE * 2, scenario.ctx());
        let list_hero = ts::take_shared<ListHero>(&scenario);

        marketplace::buy_hero(list_hero, too_low_payment, scenario.ctx());
    };

    next_tx(&mut scenario, RECIPIENT);

    scenario.end();
}

#[test]
fun test_create_arena() {
    let mut scenario = ts::begin(SENDER);

    // Create a hero first
    {
        hero::create_hero(
            b"Ercan".to_string(),
            b"https://example.com/ercan.png".to_string(),
            8000,
            scenario.ctx(),
        );
    };

    next_tx(&mut scenario, SENDER);

    // Create arena with the hero
    {
        let hero = ts::take_from_sender<Hero>(&scenario);
        arena::create_arena(hero, scenario.ctx());
        assert!(sui::event::events_by_type<ArenaCreated>().length() == 1, EDidNotEmitEvent);
    };

    next_tx(&mut scenario, SENDER);

    // Verify Arena object was created and shared
    assert!(ts::has_most_recent_shared<Arena>(), EArenaNotShared);

    ts::end(scenario);
}

#[test]
fun test_delist_hero() {
    let mut scenario = ts::begin(SENDER);

    // Create admin cap first
    {
        marketplace::test_init(scenario.ctx());
    };

    next_tx(&mut scenario, SENDER);

    // Create and list a hero
    {
        hero::create_hero(
            b"Ahmet".to_string(),
            b"https://example.com/ahmet.png".to_string(),
            7200,
            scenario.ctx(),
        );
    };

    next_tx(&mut scenario, SENDER);

    {
        let hero = ts::take_from_sender<Hero>(&scenario);
        marketplace::list_hero(hero, PRICE, scenario.ctx());
    };

    next_tx(&mut scenario, SENDER);

    // Delist the hero using admin cap
    {
        let admin_cap = ts::take_from_sender<AdminCap>(&scenario);
        let list_hero = ts::take_shared<ListHero>(&scenario);

        marketplace::delist(&admin_cap, list_hero);

        ts::return_to_sender(&scenario, admin_cap);
    };

    next_tx(&mut scenario, SENDER);

    // Verify hero was returned to seller
    assert!(ts::has_most_recent_for_sender<Hero>(&scenario), EHeroNotTransferred);

    {
        let hero = ts::take_from_sender<Hero>(&scenario);
        assert!(hero::hero_name(&hero) == b"Ahmet".to_string(), EHeroNameMismatch);
        ts::return_to_sender(&scenario, hero);
    };

    ts::end(scenario);
}

#[test]
fun test_change_the_price() {
    let mut scenario = ts::begin(SENDER);

    // Create admin cap first
    {
        marketplace::test_init(scenario.ctx());
    };

    next_tx(&mut scenario, SENDER);

    // Create and list a hero
    {
        hero::create_hero(
            b"Serkan".to_string(),
            b"https://example.com/serkan.png".to_string(),
            6800,
            scenario.ctx(),
        );
    };

    next_tx(&mut scenario, SENDER);

    {
        let hero = ts::take_from_sender<Hero>(&scenario);
        marketplace::list_hero(hero, PRICE, scenario.ctx());
    };

    next_tx(&mut scenario, SENDER);

    // Change the price using admin cap
    let new_price = 2000000000; // 2 SUI
    {
        let admin_cap = ts::take_from_sender<AdminCap>(&scenario);
        let mut list_hero = ts::take_shared<ListHero>(&scenario);

        marketplace::change_the_price(&admin_cap, &mut list_hero, new_price);

        ts::return_shared(list_hero);
        ts::return_to_sender(&scenario, admin_cap);
    };

    next_tx(&mut scenario, SENDER);
    {
        let list_hero = ts::take_shared<ListHero>(&scenario);

        assert!(marketplace::listing_price(&list_hero) == new_price, EHeroPriceMismatch);
        ts::return_shared(list_hero);
    };

    ts::end(scenario);
}

#[test]
fun test_battle_cross_user() {
    let mut scenario = ts::begin(SENDER);

    // SENDER creates a hero and battle place
    {
        hero::create_hero(
            b"Kostas".to_string(),
            b"https://example.com/kostas.png".to_string(),
            7500,
            scenario.ctx(),
        );
    };

    next_tx(&mut scenario, SENDER);

    {
        let hero = ts::take_from_sender<Hero>(&scenario);
        arena::create_arena(hero, scenario.ctx());
    };

    next_tx(&mut scenario, RECIPIENT);

    {
        hero::create_hero(
            b"Adeniyi".to_string(),
            b"https://example.com/adeniyi.png".to_string(),
            8500,
            scenario.ctx(),
        );
    };

    next_tx(&mut scenario, RECIPIENT);

    {
        let hero = ts::take_from_sender<Hero>(&scenario);
        let arena = ts::take_shared<Arena>(&scenario);

        arena::battle(hero, arena, scenario.ctx());
        assert!(sui::event::events_by_type<ArenaCompleted>().length() == 1, EDidNotEmitEvent);
    };

    next_tx(&mut scenario, RECIPIENT);

    // RECIPIENT should have received both heroes (winner gets all)
    // Kostas (8500) > Adeniyi (7500)
    let hero_ids_recipient = ts::ids_for_sender<Hero>(&scenario);
    assert!(hero_ids_recipient.length() == 2, EHeroAmountMismatch);

    // Verify SENDER has no heroes left
    next_tx(&mut scenario, SENDER);
    let hero_ids_sender = ts::ids_for_sender<Hero>(&scenario);
    assert!(hero_ids_sender.length() == 0, EHeroNotTransferred);

    ts::end(scenario);
}

#[test]
fun test_fuse_heroes() {
    let mut scenario = ts::begin(SENDER);

    // Create first hero
    {
        hero::create_hero(
            b"Hero1".to_string(),
            b"https://example.com/hero1.png".to_string(),
            5000,
            scenario.ctx(),
        );
    };

    next_tx(&mut scenario, SENDER);

    // Create second hero
    {
        hero::create_hero(
            b"Hero2".to_string(),
            b"https://example.com/hero2.png".to_string(),
            3000,
            scenario.ctx(),
        );
    };

    next_tx(&mut scenario, SENDER);

    // Verify we have 2 heroes
    let hero_ids_before = ts::ids_for_sender<Hero>(&scenario);
    assert!(hero_ids_before.length() == 2, EHeroAmountMismatch);

    // Fuse the two heroes - take them in the order they were created
    // First take the most recent (Hero2), then the older one (Hero1)
    {
        let hero2 = ts::take_from_sender<Hero>(&scenario); // Most recent (Hero2, power 3000)
        let hero1 = ts::take_from_sender<Hero>(&scenario); // Older (Hero1, power 5000)

        // Fuse with hero1 first (should preserve hero1's name and image)
        hero::fuse_heroes(hero1, hero2, scenario.ctx());
    };

    next_tx(&mut scenario, SENDER);

    // Verify we now have 1 hero (the fused one)
    let hero_ids_after = ts::ids_for_sender<Hero>(&scenario);
    assert!(hero_ids_after.length() == 1, EHeroAmountMismatch);

    // Verify the fused hero properties
    {
        let fused_hero = ts::take_from_sender<Hero>(&scenario);

        // Check name contains original name and " + (Fused)"
        let hero_name = hero::hero_name(&fused_hero);
        // Just verify the name is not empty (the format is verified by testing the function works)
        assert!(string::length(&hero_name) > 0, EHeroNameMismatch);

        // Check power is sum of both heroes (5000 + 3000 = 8000)
        assert!(hero::hero_power(&fused_hero) == 8000, EHeroPowerMismatch);

        // Check image URL is from first hero
        let hero_image = hero::hero_image_url(&fused_hero);
        let expected_image = b"https://example.com/hero1.png".to_string();
        assert!(hero_image == expected_image, EHeroImageUrlMismatch);

        ts::return_to_sender(&scenario, fused_hero);
    };

    ts::end(scenario);
}
